use std::net::SocketAddr;

use axum::{
    extract::{
        ws::{Message, WebSocket, WebSocketUpgrade},
        Extension,
    },
    response::IntoResponse,
    routing::get,
    Router,
};
use tokio::signal;
use tracing::info;
use axum::routing::get_service;
use tower_http::services::{ServeDir, ServeFile};

// --- Configuration --------------------------------------------------------

use serde::Deserialize;

#[derive(Deserialize, Debug)]
struct Settings {
    /// TCP bind address, e.g. "0.0.0.0:8080".
    #[serde(default = "default_bind")]
    bind: String,

    /// Directory to serve static assets from.
    #[serde(default = "default_static_dir")]
    static_dir: String,
}

fn default_bind() -> String {
    "0.0.0.0:8080".to_owned()
}

fn default_static_dir() -> String {
    "dist".to_owned()
}

impl Settings {
    fn load() -> anyhow::Result<Self> {
        // Priority:
        //   1. Environment variables (PREFIX_*)
        //   2. settings.{yaml,toml,env}
        //   3. Defaults from struct

        let mut cfg = config::Config::builder();

        // Optional: a `settings.yaml` near the binary / CWD.
        cfg = cfg
            .add_source(config::File::with_name("settings").required(false))
            // Environment variables in the form `APP_BIND=0.0.0.0:9000`
            .add_source(config::Environment::with_prefix("APP").separator("__"));

        Ok(cfg.build()?.try_deserialize()?)
    }
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize structured logging. Respects RUST_LOG, defaults to info.
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
        .init();

    // Load configuration (env, file, defaults).
    let settings = Settings::load()?;

    // Shared broadcast channel for arena chat.
    // Capacity is small; if lagging clients cannot keep up they will drop messages.
    let (tx, _rx) = tokio::sync::broadcast::channel::<String>(128);

    // Build application routes and inject shared state.
    // Static files service with simple internal error handler.
    // Service for static assets generated by the `frontend` build. We expose it
    // under "/assets/*" (matching Trunk's default output structure) and also
    // use it as the *fallback* service so that any request not explicitly
    // matched elsewhere will try to load a file from the static site first.

    // Directory with generated assets (e.g. `{dist}/index.html`, `{dist}/pkg/...`).
    let static_service = get_service(ServeDir::new(&settings.static_dir));

    // Fallback to the SPA's `index.html` for unknown paths so that client‑side
    // routing works (e.g. Yew `BrowserRouter`).
    let index_service = get_service(ServeFile::new(format!("{}/index.html", &settings.static_dir)));

    let app = Router::new()
        // Health‑check endpoint consumed by Caddy's reverse‑proxy.
        .route("/healthz", get(healthz))
        // Arena WebSocket endpoint.
        .route("/api/game/arena", get(arena_ws_handler))
        // Serve static assets under /assets/** so they are always reachable via
        // an explicit path (useful for caching/CDN in production).
        .nest_service("/assets", static_service.clone())
        // Anything else (i.e. "/", "/some/route", etc.) falls back to
        // `index.html` which bootstraps the SPA. This avoids the route
        // conflicts we saw when trying to register both a wildcard and an
        // explicit "/healthz" route.
        .fallback_service(index_service)
        // Shared broadcast channel for arena messaging.
        .layer(Extension(tx));

    // Use configured bind address.
    let addr: SocketAddr = settings.bind.parse()?;

    info!("listening on http://{}", addr);

    let listener = tokio::net::TcpListener::bind(addr).await?;

    axum::serve(listener, app)
        .with_graceful_shutdown(shutdown_signal())
        .await?;

    Ok(())
}

async fn healthz() -> &'static str {
    "ok"
}

async fn arena_ws_handler(
    ws: WebSocketUpgrade,
    Extension(tx): Extension<tokio::sync::broadcast::Sender<String>>,
) -> impl IntoResponse {
    ws.on_upgrade(move |socket| handle_socket(socket, tx))
}

async fn handle_socket(mut socket: WebSocket, tx: tokio::sync::broadcast::Sender<String>) {
    // Subscribe to the broadcast channel to receive messages from other clients.
    let mut rx = tx.subscribe();

    loop {
        tokio::select! {
            // Receive message from WebSocket client
            from_client = socket.recv() => {
                match from_client {
                    Some(Ok(Message::Text(text))) => {
                        // Broadcast to all listeners; ignore error if there are no receivers.
                        let _ = tx.send(text);
                    }
                    Some(Ok(Message::Binary(_))) => {
                        // Ignore binary frames for now.
                    }
                    Some(Ok(Message::Ping(p))) => {
                        if socket.send(Message::Pong(p)).await.is_err() {
                            break;
                        }
                    }
                    Some(Ok(Message::Close(_))) => {
                        break;
                    }
                    Some(Ok(Message::Pong(_))) => {}
                    Some(Err(_)) | None => {
                        // Client disconnected or error.
                        break;
                    }
                }
            }

            // Receive broadcasted message from other client(s).
            from_broadcast = rx.recv() => {
                match from_broadcast {
                    Ok(msg) => {
                        if socket.send(Message::Text(msg)).await.is_err() {
                            break;
                        }
                    }
                    Err(tokio::sync::broadcast::error::RecvError::Lagged(_)) => {
                        // Skip missed messages.
                        continue;
                    }
                    Err(tokio::sync::broadcast::error::RecvError::Closed) => {
                        break;
                    }
                }
            }
        }
    }
}

async fn shutdown_signal() {
    // Wait for SIGINT or SIGTERM.
    let ctrl_c = async {
        signal::ctrl_c().await.expect("failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        use tokio::signal::unix::{signal, SignalKind};
        let mut sigterm = signal(SignalKind::terminate()).expect("failed to install SIGTERM handler");
        sigterm.recv().await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => {},
        _ = terminate => {},
    }

    info!("signal received, starting graceful shutdown");
}
